## Transform the family table for linear regression of the abundance of different family
We split the dataframe by Family to create a list of dataframes, each have one family. We then merge all the small dataframes by column binding. The result is a dataframe with much less row and much more column, i.e. the number of row is equal to the number of samples we have. We also need to rename the Abundance column for each small dataframe so we can call out later the Abundance of interest. 

```
list1 <- split(pd_agg_family, pd_agg_family$Family, drop=F)


rename_Abundance1<-function (df) {
colnames(df)[colnames(df)=="Abundance"] <- paste("Abundance_", df$Family[1])
colnames(df)[colnames(df)=="Phylum"] <- paste("Phylum_", df$Family[1])
colnames(df)[colnames(df)=="Class"] <- paste("Class_", df$Family[1])
colnames(df)[colnames(df)=="Order"] <- paste("Order_", df$Family[1])
df <- subset(df, select= - c(OTU, Genus, Species, Kingdom))
return(df)
}

#Or below 
#rename_Abundance1<-function (df) {
#colnames(df)[3] <- paste("Abundance_", df$Family[1])
#}

for (i in 1:length(list1)) {
list1[[i]] <- rename_Abundance1(list1[[i]])
} # list1 has a list of list of dataframes. list1[i]is a list with one element, list1[[i]] is a dataframe.

for (i in 1:length(list1)) {
list1[[i]] <- subset (list1[[i]], select = -c(Family))
} #optional, remove the column. 

all_abundance <- list1[[1]] 
all_abundance <- merge(all_abundance, list1[[2]], 
by= c("Sample","EarTag","Group","Source","Treatment","Genotype","TreatmentWeek","WeekTreatment","Individual"))

for (i in 2:length(list1)) 
{all_abundance <- merge(all_abundance, list1[[i]], 
by= c("Sample","EarTag","Group","Source","Treatment","Genotype","TreatmentWeek","WeekTreatment","Individual"))
}
str(all_abundance) 

names(all_abundance) <- gsub(" ", "", names(all_abundance))#Remove space in column names
names(all_abundance) <- gsub("-", "_", names(all_abundance))#Change - to _ in column names.

write.csv(all_abundance, "all_abundance.csv")
```

## Add Lcn2 data to 16S data
I want to study the correlations between Lcn2 concentration and abundance. First, add a column with Lcn2 concentration to the dataframe: 

```  
lcn2 <- read.table(file="Lcn2bySampleID.txt")
lcn2 <- lcn2 %>% rename(Sample = SampleID) #rename the column SampleID to Sample 
family_lcn2 <- merge(all_abundance, lcn2, by.x= "Sample", all.x=TRUE)
```

To test the correlation between two column of interest, you can either visually compare or calculate cor. (R^2 = cor^2). cor is a value between 0 to 1. <0.2 means no correlation, 0.2-0.5 moderate, 0.5-0.7 weak, 0.7-1 strong. 
``` 
ggplot(all_abundance, aes(x=Abundance_Lactobacillaceae, y=Abundance_S24_7,color=Treatment)) + 
         geom_point()+geom_smooth(method = "lm")

ggplot(family_lcn2, aes(x=Lcn2_ug_per_mg_feces, y=Abundance_Bacteroidaceae,color=Treatment))+ 
         geom_point()+geom_smooth(method = "lm")
         
ggplot(family_lcn2, aes(x=Lcn2_ug_per_mg_feces, y=Abundance_S24_7, color=Source))+ 
         geom_point()+geom_smooth(method = "lm")

linearMod <- lm(Abundance_S24_7 ~ Lcn2_ug_per_mg_feces, data=family_lcn2)  
print(linearMod)
summary(linearMod)

cor(family_lcn2$Abundance_S24_7, family_lcn2$Lcn2_ug_per_mg_feces, use="complete.obs")

```
Or we could first normalize each factor by (x-mean)/SD. This won't change R^2 value. 
```
x <- (family_lcn2$Abundance_S24_7 - mean(family_lcn2$Abundance_S24_7, na.rm=TRUE))/sd(family_lcn2$Abundance_S24_7, na.rm=TRUE)
y <- (family_lcn2$Lcn2_ug_per_mg_feces - mean(family_lcn2$Lcn2_ug_per_mg_feces, na.rm=TRUE))/sd(family_lcn2$Lcn2_ug_per_mg_feces, na.rm=TRUE)
ggplot(data.frame(x=x, y=y), aes(x=x, y=y))+ geom_point()+geom_smooth(method = "lm")
cor(x,y,use="complete.obs")
summary(lm(x~y,data.frame(x=x,y=y)))

ggplot(family_lcn2, aes(x=Lcn2_ug_per_mg_feces, y=Abundance_Bacteroidaceae,color=Treatment))
      +geom_point()+geom_smooth(method = "lm")
ggplot(family_lcn2, aes(x=Lcn2_ug_per_mg_feces, y=Abundance_S24_7, color=Source))
      +geom_point()+geom_smooth(method = "lm")
```
Can also do linear regression between each OTU abundance and Lcn2. 
```
OTU_lcn2 <- merge(pd_rarefy, lcn2, by.x="Sample", all.x=TRUE)
ggplot(OTU_lcn2%>%filter(OTU=="02408cd609a6b7f8134da2f8955136ac"), aes(x=Abundance, y=Lcn2_ug_per_mg_feces))+
           geom_point()+geom_smooth(method ="lm")
g<-OTU_lcn2%>%filter(OTU=="02408cd609a6b7f8134da2f8955136ac")
cor(g$Lcn2_ug_per_mg_feces,g$Abundance,use="complete.obs")          
```
*Use split and sapply, we could do this for all OTU and rank them based on cor. 

## t.test
The function t.test(X~Y,mu=0, alt="two.sided", conf=0.95, var.eq=F, paired=F) performs Welch Two Sample t-test. mu = 0 means null hypothesis is that the two is equal. var.eq=F- not same number of sample. The above are the default setting. Can also use t.test(df$X, df$Y). 

```
attach(pd_agg_family)
t.test(Abundance~Treatment,mu=0, alt="two.sided", conf=0.95, var.eq=F, paired=F)
t.test(Abundance[TreatmentWeek=="IL10-SPF W0"], Abundance[TreatmentWeek=="IL10-SPF+BF W0"])

# Mann Whitney U / Wilcoxon Rank-Sum test comparing the median of each group
wilcox.test(Abundance~Treatment, mu=0, alt="two.sided", conf=0.95, paired=F, exact=F, correct=T, conf.inf=T)
```
To do t-test for every family and every week, first write a function and then sapply.
```
t.test_pvalue <- function (df, a="Abundance", f="Treatment") {
 l <- t.test(df[[a]]~df[[f]])
 return(l[["p.value"]])
}
Family_t <- ddply(pd_agg_family,.(pd_agg_family$Family, pd_agg_family$Source),t.test_pvalue,a="Abundance", f="Treatment")
Significant_Family<- Family_t %>% rename (pvalue=V1) %>% arrange(pvalue)%>% filter(pvalue<0.1)
write.csv(Significant_Family,"SignificantFamily.csv")
```
## Power calculation

The function *power.t.test* can calculate power or N or type1 error when you provide the SD of pooled group, the difference in the mean value, and two out of the three factors. For example, you can provide type I error and desired power, and it will calculate N number required in order to detect the difference between the mean. The larger the difference is, the smaller n you'll need to obtain enough power for the desired type 1 error. 

First, calculate mean for each group and SD for pooled data. Then calculate N number required - assuming type 1 error = 0.1 and power = 0.8. 

```
family_lcn2 %>% group_by(TreatmentWeek)%>% select(Lcn2_ug_per_mg_feces,TreatmentWeek)%>%filter(Lcn2_ug_per_mg_feces>0)%>%summarise_each(funs(mean,sd,length))

lcn2_pooled_sd <- family_lcn2 %>% group_by(Source)%>% select(Lcn2_ug_per_mg_feces,Source) %>% filter(Lcn2_ug_per_mg_feces>0) %>% summarise_each(funs(mean,sd,length))

for (i in 1:4) {lcn2_pooled_sd$power[i] <- (power.t.test(delta = lcn2_g$mean[i+4]-lcn2_g$mean[i], sd = lcn2_pooled_sd$sd[i], sig.level = 0.1,  power = 0.8, type = "two.sample", alternative = "two.sided")$n)}
lcn2_pooled_sd
```

## t.test for OTU

From the file of OTU_lcn2, we can split by OTU to generate a list. For each OTU, we can apply the t.test_pvalue function above. 
```
OTU_lcn2_gavage <- OTU_lcn2%>%filter(Source!=0)
list_OTU1 <- split(OTU_lcn2_gavage, OTU_lcn2_gavage$OTU, drop=F)
OTU_p<-as.data.frame(sapply(list_OTU1,t.test_pvalue))
OTU_p<-cbind(rownames(OTU_p),data.frame(OTU_p,row.names=NULL))
names(OTU_p)<-c("OTU","pvalue") #OTU_p contains the p-value of all OTUs
OTU_sig<- OTU_p%>%filter(pvalue<0.1)%>%arrange(pvalue)

## add one column (before VS after gavage - as factor (source)), calculate difference in t-test (both Lcn2 and key family/OTU) 
